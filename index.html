<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>动作捕捉App</title>
  <script src="/SkeletonActionRecognition/pose.js"></script>
  <script src="/SkeletonActionRecognition/camera_utils.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-100 flex flex-col items-center justify-center h-screen">
  <h1 class="text-3xl font-bold mb-4">实时动作捕捉</h1>
  <div class="flex space-x-4">
    <div>
      <video id="video" class="hidden"></video>
      <canvas id="canvas" class="border rounded-lg" width="640" height="480"></canvas>
    </div>
    <div class="flex flex-col space-y-4">
      <div class="bg-white p-4 rounded shadow">
        <h2 class="text-xl font-semibold">跳绳计数</h2>
        <p>跳跃次数: <span id="jumpCount">0</span></p>
      </div>
      <div class="bg-white p-4 rounded shadow">
        <h2 class="text-xl font-semibold">切水果</h2>
        <p>得分: <span id="fruitScore">0</span></p>
      </div>
    </div>
  </div>

  <script>
    const videoElement = document.getElementById('video');
    const canvasElement = document.getElementById('canvas');
    const canvasCtx = canvasElement.getContext('2d');
    const jumpCountElement = document.getElementById('jumpCount');
    const fruitScoreElement = document.getElementById('fruitScore');

    let jumpCount = 0;
    let fruitScore = 0;
    let lastAnkleY = null;
    let lastHandPos = null;
    let isJumping = false;

    // 虚拟水果对象
    const fruits = [
      { x: 200, y: 100, radius: 20, active: true },
      { x: 400, y: 150, radius: 20, active: true }
    ];

    // MediaPipe Pose 初始化
    const pose = new Pose({
      locateFile: (file) => `/SkeletonActionRecognition/${file}`
    });
    pose.setOptions({
      modelComplexity: 1,
      smoothLandmarks: true,
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5
    });
    pose.onResults(onResults);

    // 摄像头设置
    const camera = new Camera(videoElement, {
      onFrame: async () => {
        await pose.send({ image: videoElement });
      },
      width: 640,
      height: 480
    });
    camera.start();

    // 处理姿势检测结果
    function onResults(results) {
      canvasCtx.save();
      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
      canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

      if (results.poseLandmarks) {
        // 绘制关键点
        drawLandmarks(results.poseLandmarks);

        // 跳绳逻辑：检测脚踝Y坐标变化
        const ankle = results.poseLandmarks[28]; // 右脚踝
        if (ankle) {
          const ankleY = ankle.y * canvasElement.height;
          if (lastAnkleY !== null) {
            const deltaY = ankleY - lastAnkleY;
            if (!isJumping && deltaY < -20) {
              isJumping = true;
            } else if (isJumping && deltaY > 20) {
              isJumping = false;
              jumpCount++;
              jumpCountElement.textContent = jumpCount;
            }
          }
          lastAnkleY = ankleY;
        }

        // 切水果逻辑：检测手部快速移动
        const hand = results.poseLandmarks[20]; // 右手腕
        if (hand) {
          const handPos = { x: hand.x * canvasElement.width, y: hand.y * canvasElement.height };
          if (lastHandPos) {
            const speed = Math.sqrt(
              Math.pow(handPos.x - lastHandPos.x, 2) + Math.pow(handPos.y - lastHandPos.y, 2)
            );
            if (speed > 50) { // 快速移动判断为“切”
              fruits.forEach(fruit => {
                if (fruit.active) {
                  const dist = Math.sqrt(
                    Math.pow(handPos.x - fruit.x, 2) + Math.pow(handPos.y - fruit.y, 2)
                  );
                  if (dist < fruit.radius + 20) {
                    fruit.active = false;
                    fruitScore++;
                    fruitScoreElement.textContent = fruitScore;
                  }
                }
              });
            }
          }
          lastHandPos = handPos;
        }
      }

      // 绘制虚拟水果
      fruits.forEach(fruit => {
        if (fruit.active) {
          canvasCtx.beginPath();
          canvasCtx.arc(fruit.x, fruit.y, fruit.radius, 0, Math.PI * 2);
          canvasCtx.fillStyle = 'red';
          canvasCtx.fill();
          canvasCtx.closePath();
        }
      });

      canvasCtx.restore();
    }

    // 绘制关键点和连线
    function drawLandmarks(landmarks) {
      const connections = [
        [11, 12], [11, 13], [13, 15], [12, 14], [14, 16], // 上半身
        [11, 23], [12, 24], [23, 24], [23, 25], [24, 26], // 躯干
        [25, 27], [26, 28], [27, 29], [28, 30] // 下半身
      ];
      for (const [start, end] of connections) {
        canvasCtx.beginPath();
        canvasCtx.moveTo(
          landmarks[start].x * canvasElement.width,
          landmarks[start].y * canvasElement.height
        );
        canvasCtx.lineTo(
          landmarks[end].x * canvasElement.width,
          landmarks[end].y * canvasElement.height
        );
        canvasCtx.strokeStyle = 'blue';
        canvasCtx.lineWidth = 2;
        canvasCtx.stroke();
      }
      for (const landmark of landmarks) {
        canvasCtx.beginPath();
        canvasCtx.arc(
          landmark.x * canvasElement.width,
          landmark.y * canvasElement.height,
          5,
          0,
          Math.PI * 2
        );
        canvasCtx.fillStyle = 'green';
        canvasCtx.fill();
      }
    }
  </script>
</body>
</html>